/*
 * > Desc: Automatically generated by the 'WHENEVER EVERYWHERE' code transpiler
 * > TranspilerVersion: 0.0.0a3
 * > OriginalFile: code1.txt
*/

#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <ctype.h>

//
// DEFINITIONS
//

#ifndef TypeDefinitions
#define TypeDefinitions
typedef int bool ;
typedef int error;
#define True 1
#define False 0
typedef unsigned int uint ;
typedef unsigned long long llu ;
typedef long long ll ;
#endif

#ifndef ArithmeticDefinitions
#define ArithmeticDefinitions
#define USING_64_BITS_TRACKING True
#define USE_LL_IN_OPERATIONS True
#endif

#ifndef ErrorHandlingAndDebuggingBehaviour
#define ErrorHandlingAndDebuggingBehaviour
#define SKIP_ERRORS False
#define DEBUGGING True
#define DEBUGGING_PATH "1.txt"
#endif

#ifndef TranspiledCodeInfo
#define TranspiledCodeInfo
#define TOTAL_LINES 1
#endif

/// DEBUGGING

#if DEBUGGING

FILE *fptr;

int start_log_if_debugging(){
    fptr = fopen( DEBUGGING_PATH , "w+") ;
    if (fptr == NULL){
        fprintf( stderr, "Error creating/opening log file.\n");
        exit(1);
    }
    return 0;
}

#define debug_log(...) fprintf(fptr, __VA_ARGS__); fflush(fptr);

int close_log_if_debugging() {return fclose(fptr);}

#else // NOT_DEBUGGING
#define start_log_if_debugging() // EMPTY DEF
#define debug_log(...) // EMPTY DEF
#define close_log_if_debugging() // EMPTY DEF
#endif


// ERRORS HANDLER


#if SKIP_ERRORS
void raise_error(error error_number){} // EMPTY DEF

#else // NOT_SKIP_ERRORS

#define case_error(i, e) case i: fprintf( stderr, e) ; break;

#define INVALID_ACTIVE_LINE 1
#define INVALID_LINE_POSITION 2
#define LINE_OVERFLOW 3
#define SUM_OVERFLOW 4
#define MINUS_OVERFLOW 5
#define TIMES_OVERFLOW 6
#define DIV_ZERO 7


void raise_error(error error_number){
    fprintf( stderr, "ERROR ");
    debug_log("~~~~~~~\n");
    debug_log("!!ERROR: %d", error_number);
    switch(error_number){
       case_error(INVALID_ACTIVE_LINE, "(INNER: INVALID ACTIVE LINE)");
       case_error(INVALID_LINE_POSITION, "(INNER: INVALID LINE POSITION)");
       case_error(LINE_OVERFLOW, "(INNER: LINE QUANTITY OVERFLOW)");
       case_error(SUM_OVERFLOW, "(MATH: SUM OVERFLOW/UNDERFLOW)");
       case_error(MINUS_OVERFLOW, "(MATH: MINUS OVERFLOW/UNDERFLOW)");
       case_error(TIMES_OVERFLOW, "(MATH: TIMES OVERFLOW/UNDERFLOW)");
       case_error(DIV_ZERO, "(MATH: DIV BY 0)");
       default: fprintf( stderr, "(?)");
    }
    fprintf( stderr, "\n");
    close_log_if_debugging();
    exit(error_number);
}
#endif


/// ARITHMETIC

#if USE_LL_IN_OPERATIONS

static inline ll __sum(ll X, ll Y, error error_id){
    ll sum = X+Y;
    if(X>=0 && Y>=0){
        if(sum < X || sum < Y) raise_error(error_id);
    }else if(X<=0 && Y<=0){
        if(sum > X || sum > Y) raise_error(error_id);
    }else if(X>=0){ // Y<0
        if(sum > X || sum < Y) raise_error(error_id);
    }else{ // X<0 && Y>0
        if(sum < X || sum > Y) raise_error(error_id);
    }
    return sum;
}

ll _add(ll X, ll Y){
    return __sum(X,Y,SUM_OVERFLOW);
}

ll _minus(ll X, ll Y){
    ll Y2 = -1 * Y; // Just reverse the symbol and do an addition
    if( (Y + Y2) != 0 ) raise_error(MINUS_OVERFLOW); // Incredibly border case of max_long, might be unnecessary
    return __sum(X, Y2, MINUS_OVERFLOW);
}

#define _times(X, Y) (X * Y) // Need to redefine to check overflows

ll _divide(ll X, ll Y){
    if(Y == 0) raise_error(DIV_ZERO);
    return X/Y;
}

#else // USE_DEFAULT

#define _add(X,Y) (X + Y)
#define _minus(X,Y) (X - Y)
#define _times(X, Y) (X * Y)
#define _divide(X,Y) (X/Y)

#endif


//
// INPUT HANDLER
//

const int LINE_FEED = '\n';
const int NUMERIC_CHAR_OFFSET = '0';
const int EMPTY_BUFFER = -1;

int char_buffer = EMPTY_BUFFER;
int get_input() {
    int answer = 0;

    // EMPTY BUFFER IF NOT EMPTY
    if( char_buffer != EOF && char_buffer != LINE_FEED && char_buffer != EMPTY_BUFFER ) {
        answer = char_buffer;
        char_buffer = EMPTY_BUFFER;
        return answer;
    }

    // GET INPUT
    int next_char = getchar();

    // IF WE RECEIVE A NON-NUMERIC ASCII CHAR, RETURN IT
    if(!isdigit(next_char)) return next_char;

    // PROCESS WHOLE NUMBER
    do{
        answer *= 10; // MULTIPLY FOR 10 TO MOVE PREVIOUS ANSWER ONE SPACE TO THE LEFT
        answer += next_char - NUMERIC_CHAR_OFFSET;
        next_char = getchar();
    } while(isdigit(next_char));

    // BUFFER GETS USED TO GET LEFTOVER CHAR IN NEXT RUN
    char_buffer = next_char;

    return answer;

}



//
// 64BIT RANDOM
//

#if USING_64_BITS_TRACKING
#ifndef RAND_MAX_WIDTH
// This could really improve, code from here:
//     https://stackoverflow.com/questions/33010010/how-to-generate-random-64-bit-unsigned-integer-in-c
#define IMAX_BITS(m) ((m)/((m)%255+1) / 255%255*8 + 7-86/((m)%255+12))
#define RAND_MAX_WIDTH IMAX_BITS(RAND_MAX)
_Static_assert((RAND_MAX & (RAND_MAX + 1u)) == 0, "RAND_MAX not a Mersenne number");

llu rand64() {
    llu r = 0;
    for (int i = 0; i < 64; i += RAND_MAX_WIDTH) {
        r <<= RAND_MAX_WIDTH;
        r ^= (unsigned) rand();
    }
    return r;
}

#endif
#endif

//
// STRUCTS AND ARRAYS
//

typedef struct Line Line;
typedef struct StackCount StackCount;

struct Line {
    uint line_number;
    void (*func) (void);
};

struct StackCount {
    uint line_number;
    #if USE_LL_IN_OPERATIONS
    ll count;
    #else // NOT_USE_LL_IN_OPERATIONS
    llu count;
    #endif
};

Line lines [TOTAL_LINES];
StackCount executionStack [TOTAL_LINES];

#if DEBUGGING
void debug_log_stack(){
    for(uint i = 0; i< TOTAL_LINES; i++)
        #if USE_LL_IN_OPERATIONS
        debug_log("|%u:%ll| ", executionStack[i].line_number, executionStack[i].count);
        #else // NOT_USE_LL_IN_OPERATIONS
        debug_log("|%u:%llu| ", executionStack[i].line_number, executionStack[i].count);
        #endif
    debug_log("\n");
}
#else // NOT_DEBUGGING
#define debug_log_stack() // EMPTY DEF
#endif

//
// STRUCT FUNCTIONS
//

#if USING_64_BITS_TRACKING
llu get_active_lines(){
    llu long_count = 0;
    for (uint i = 0; i < TOTAL_LINES; i++) {
        long_count += executionStack[i].count;
    }
    return long_count;
}

#else // NOT USING_64_BITS_TRACKING
uint get_active_lines(){
    // Due to memory limitations, Active lines outside of 64 bits does not mean all the lines
    // that are active, but the cluster of lines that have more than 1 entry.
    //
    // This means that each line is equally likely to be chosen, no matter many entries it has.
    // This is not consistent with Whatever behaviour, but it's good enough to test code in general.
    uint count = 0;
    for (uint i = 0; i < TOTAL_LINES; i++) {
        if(executionStack[i].count > 0) count += 1;
    }
    return count;
}
#endif


#if USING_64_BITS_TRACKING
uint get_position_of_active_line(llu active_line){
    uint i = 0;
    while( (active_line > 0) && (i < TOTAL_LINES) ){
        if( executionStack[i].count > active_line ){
            active_line = 0;
        }else{
            active_line -= executionStack[i].count;
        }
        if(active_line > 0) i += 1;
    };
    if(i >= TOTAL_LINES) raise_error(INVALID_ACTIVE_LINE);
    return i;
}

#else // NOT USING_64_BITS_TRACKING
uint get_position_of_active_line(uint active_line){
    uint i = 0;
    while( (active_line > 0) && (i < TOTAL_LINES) ){
        // Since outside of 64 bits we use active lines as a group of lines,
        // we only need to reduce 1 active_line per line group.
        if(executionStack[i].count > 0) active_line -= 1;
        if(active_line > 0) i += 1;
    };
    if(i >= TOTAL_LINES) raise_error(INVALID_ACTIVE_LINE);
    return i;
}
#endif

void change_pos_quantity(uint position, long long quantity) {
    llu new_quantity = executionStack[position].count + quantity ;
    // This weird branching is here to detect an overflow
    if (quantity < 0 ){
        // Underflow raises no errors, it sets the values to 0
        if (new_quantity > executionStack[position].count ) new_quantity = 0;
        executionStack[position].count = new_quantity;
    }else{
        // Overflow raises an error
        if ( new_quantity < executionStack[position].count ) raise_error(LINE_OVERFLOW);
        executionStack[position].count = new_quantity;
    }
}

//
// UNUSED
//

uint get_line_pos(uint line_number){
    uint i = 0;
    // TODO improve this, a linear search will give terrible performance
    while( (lines[i].line_number != line_number) && i < (TOTAL_LINES) ) i += 1;

    if(i >= TOTAL_LINES) raise_error(INVALID_LINE_POSITION);
    return i;
}

llu get_line_quantity(uint line_number){
    return executionStack[get_line_pos(line_number)].count;
}

void change_lines_quantity(uint line_number, long long quantity) {
    uint position = get_line_pos(line_number);
    change_pos_quantity(position, quantity);
}

//
// LINES
//

// THESE FUNCTIONS WERE AUTOMATICALLY GENERATED

void F0_for_line1(void) { 
    bool defer = False ;
    if(!defer){
        bool again = False || ( (executionStack[0].count) > (0));
        // Starting statements 
        printf("%c", get_input());
        printf("\n");
        // Statements done
        if(!again) change_pos_quantity(0, -1);
    }
}

//
// MAIN
//

int main() {

    start_log_if_debugging();
    debug_log("Started\n");
    debug_log("~~~~~~~\n");

    // THESE DEFINITIONS WERE AUTOMATICALLY GENERATED
    lines[0]= (Line) {1, &F0_for_line1};
    executionStack[0] = (StackCount) {1,1};

    #if USING_64_BITS_TRACKING
    llu active_lines = TOTAL_LINES;
    debug_log("ACTIVE LINES [%llu]\n", active_lines);

    #else // NOT USING_64_BITS_TRACKING
    uint active_lines = TOTAL_LINES;
    debug_log("ACTIVE LINES [%u]\n", active_lines);
    #endif

    do{

        #if USING_64_BITS_TRACKING // Not perfect but should be good enough
        llu next_active_line = rand64()%(active_lines+1) ;
        debug_log("picked %llu", next_active_line);

        #else // NOT USING_64_BITS_TRACKING
        uint next_active_line = rand()%(active_lines+1);
        debug_log("picked %u", next_active_line);
        #endif

        uint position = get_position_of_active_line(next_active_line);
        debug_log(" ( line %u ) -> ", lines[position].line_number);
        lines[position].func();
        debug_log_stack();
        active_lines = get_active_lines();

    }while(active_lines > 0);

    debug_log("~~~~~~~\n");
    debug_log("NO ERRORS\n");
    close_log_if_debugging();
    return 0;

}
